# Configuration file for Milvus Geo Benchmark Tool
# Copy this file to config.yaml and customize as needed

dataset:
  # Number of training points to generate
  num_points: 100000
  
  # Number of test queries to generate
  num_queries: 1000
  
  # Output directory for generated datasets
  output_dir: ./data
  
  # Bounding box for point generation [min_lon, min_lat, max_lon, max_lat]
  # Example: World [-180, -90, 180, 90]
  # Example: Beijing area [116.0, 39.5, 117.0, 40.5]
  bbox: [-180, -90, 180, 90]
  
  # Minimum number of points that each query should return
  min_points_per_query: 100
  
  # Grid-based generation for large datasets (optimizes memory usage)
  grid:
    # Enable grid partitioning (auto-enabled for datasets > 10M points)
    enabled: false
    
    # Automatically calculate optimal grid layout based on data size
    auto_calculate: true
    
    # Target number of points per grid (1M recommended for balance of memory/performance)
    target_points_per_grid: 1000000
    
    # Minimum and maximum number of grids
    min_grids: 1
    max_grids: 1000
    
    # Optional: Manual grid layout [rows, cols] - overrides auto_calculate
    # grid_layout: [10, 10]

# Milvus connection configuration
milvus:
  # Milvus server URI (use environment variable)
  uri: ${MILVUS_URI}
  
  # Milvus authentication token (use environment variable)
  token: ${MILVUS_TOKEN}
  
  # Collection name for storing geo data
  collection: geo_bench
  
  # Batch size for data insertion
  batch_size: 1000
  
  # Connection timeout in seconds
  timeout: 30

  # Index creation during data loading (deprecated - moved to benchmark section)
  # Indexes are now created during benchmark step for better control
  # create_indexes: true

# Benchmark execution settings
benchmark:
  # Query timeout in seconds
  timeout: 30

  # Number of warmup queries to run before measurement
  warmup: 10

  # Concurrency levels to test (can be single value or array)
  # Examples:
  # concurrency: 100                    # Single concurrency level
  # concurrency: [10, 50, 100, 200]     # Multiple levels for QPS optimization
  concurrency: 100

  # Auto-scaling configuration for finding maximum QPS
  auto_extend_concurrency: false        # Enable auto-extension beyond configured levels
  max_concurrency_limit: 1000           # Maximum concurrency to test
  qps_growth_threshold: 5               # Minimum QPS growth % to continue scaling
  max_error_rate: 0.05                  # Stop scaling if error rate exceeds this

  # Index creation control
  create_vector_index: true             # Create vector index before benchmark
  create_geo_index: true                # Create geo index before benchmark
                                        # Note: If set to false, existing indexes will be dropped
                                        # Collection will be released and reloaded during index operations
                                        # Other collections are automatically released to free memory

# Output settings
output:
  # Benchmark results file
  results: ./data/results.parquet
  
  # Evaluation report file
  report: ./reports/evaluation_report.md

# Example configurations for different scenarios:
#
# Small test dataset (legacy mode):
# dataset:
#   num_points: 10000
#   num_queries: 100
#   grid:
#     enabled: false
#
# Large scale benchmark (auto-enable grid):
# dataset:
#   num_points: 100000000  # 100M points - will auto-enable grid mode
#   num_queries: 10000
#   grid:
#     target_points_per_grid: 5000000  # 5M points per grid
#
# Manual grid configuration for 25M points:
# dataset:
#   num_points: 25000000
#   num_queries: 5000  
#   grid:
#     enabled: true
#     auto_calculate: false
#     grid_layout: [5, 5]  # 25 grids in 5x5 layout
#
# Specific geographic region (San Francisco Bay Area):
# dataset:
#   bbox: [-122.5, 37.0, -121.5, 38.0]
#   num_points: 1000000
#   grid:
#     enabled: true
#     target_points_per_grid: 500000

# Concurrency testing examples:
#
# Test single concurrency level:
# benchmark:
#   concurrency: 100
#
# Test multiple concurrency levels to find optimal QPS:
# benchmark:
#   concurrency: [10, 50, 100, 200, 400]
#   auto_extend_concurrency: false
#
# Auto-scale to find maximum QPS:
# benchmark:
#   concurrency: [10, 50, 100]
#   auto_extend_concurrency: true
#   max_concurrency_limit: 2000
#   qps_growth_threshold: 3
#
# Test with/without geo index:
# benchmark:
#   concurrency: [50, 100, 200]
#   create_vector_index: true
#   create_geo_index: false  # Test without geo index (will drop existing RTREE)
#
# Usage Examples:
#
# Generate small dataset (legacy mode):
#   milvus-geo-bench --config config.yaml generate-dataset --num-points 100000
#
# Generate large dataset (auto-enable grid):
#   milvus-geo-bench --config config.yaml generate-dataset --num-points 100000000
#
# Generate with explicit grid configuration:
#   milvus-geo-bench --config config.yaml generate-dataset \
#     --num-points 50000000 --grid-enabled --target-points-per-grid 5000000
#
# Load data (indexes created later during benchmark):
#   milvus-geo-bench --config config.yaml load-data
#
# Run benchmark with multiple concurrency levels:
#   milvus-geo-bench --config config.yaml run-benchmark --concurrency "10,50,100,200"
#
# Run benchmark with auto-scaling:
#   milvus-geo-bench --config config.yaml run-benchmark --auto-extend --max-concurrency 1000
#
# Test without geo index:
#   milvus-geo-bench --config config.yaml run-benchmark --no-create-geo-index
#
# Test specific concurrency with custom settings:
#   milvus-geo-bench --config config.yaml run-benchmark \
#     --concurrency "50,100,200" --auto-extend --max-concurrency 500